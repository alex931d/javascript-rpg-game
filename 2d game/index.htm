<!DOCTYPE html>

<html>

  <head>

    <meta charset = "utf-8">
    <meta name = "viewport" content = "width=device-width">
   
    <title>Action-light</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>

      * { margin:0; padding:0; }

      html, body {
         background-color:black; height:100%; position:relative; width:100%;
        /* background-image: url(grass.png); */
        position: relative;
        display:grid
          
        
        }

      canvas { height:100%; position:fixed; width:100%;
          box-shadow: 9px 10px 5px 0px rgba(255,255,255,0.75);
-webkit-box-shadow: 9px 10px 5px 0px rgba(255,255,255,0.75);
-moz-box-shadow: 9px 10px 5px 0px rgba(255,255,255,0.75); 
align-self: center;
justify-content: center;
   
      }
      .menu-wrapper{
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0 auto;
        height: 100%;
        width: 100%;
        background-color: rgba(132, 128, 132, 0.53);
        background-image: url(./background/main\ background.webp);
        background-repeat: no-repeat;
        background-size: cover;
        flex-direction: column;
        position: fixed;
       
      
      }
      .top{
        height: 40vh;
        width: 50vh;
     
        display: flex;
        justify-content: center;
        align-items: center;
       
        flex-direction: column;
        
      }
      a{
        border: none;
          padding-left: 90px;
       padding-right: 90px;
 
    
        font-weight: 700;
        font-family: 'VT323', monospace;
        font-size: 2rem;
        color: white;
         background-color: rgba(115, 219, 150, 0.646);
         border: none;
         margin-top: 30px;
         text-align: center;
         cursor: pointer;
         
        
        
      }
      a:hover{
        background-color: rgb(115, 219, 150);
       
       padding-left: 100px;
       padding-right: 100px;
       padding-top: 10px;
       padding-bottom: 10px;
      }
      h1{
        color: white;
        font-family: 'VT323', monospace;
        font-size: 4rem;
      }
 
     
     
    
      a:nth-child(2){
        margin-top: 20px;
      }
      canvas img{
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
         
      }
      .hide{
        display: none;
      }

    </style>

  </head>

  <body>

    <canvas></canvas>
 
    <div class="menu-wrapper">
       
      <div class="top">
        <h1>RPG Action Game</h1>
       <a class="play">Play Game</a>
        <a class="Load">Load Game</a>
      </div>
    </div>
    <script src="./js/soundmanager2.js"></script>
    <script type = "text/javascript">



     






 var mainMusic = new Audio('./sounds/main.mp3');

mainMusic.play();


const btn = document.querySelector('.play');
const menu = document.querySelector('.menu-wrapper');
btn.addEventListener('click',function () {
  
  btn.classList.toggle('hide');
  menu.classList.toggle('hide');
  PlayGame();
  mainMusic.pause();
  


});
// start game
function PlayGame() {
      
     
 document.addEventListener('load',function() {
    
  });

  class Sprite {

constructor(x, y, sx, sy, w, h) {

  this.x = x; this.y = y; this.sx = sx; this.sy = sy; this.w = w; this.h = h;

  this.vx = this.vy = 0;

}

collidePoint(point) {

  if (point.x < this.x || point.x > this.x + this.w || point.y < this.y || point.y > this.y + this.h) return false;

  return true;

}

collideRect(sprite) {
  
  if (this.x > sprite.x + sprite.w || this.x + this.w < sprite.x || this.y > sprite.y + sprite.h || this.y + this.h < sprite.y) return false;

  return true;
      
}

updatePosition(gravity, friction, floor) {

  this.vy += gravity;

  this.x += this.vx;
  this.y += this.vy;

  this.vx *= friction;
  this.vy *= friction;

  if (this.y + this.h > floor) {

    this.y = floor - this.h;
    this.vy = 0;

  }

}

}

     
  class Inventory {

constructor(x, y, w, h) {

  this.x = x; this.y = y; this.w = w; this.h = h;
  this.color = "rgba(255, 255, 255, 0.5)";
  this.items = new Array();
  this.columns = 4;

}

addItem(sprite) {
  
  if (this.items.length == this.columns) {

    sprite.vy = -4;
    return false;

  }

  this.items.push(sprite)

  return true;
      
}

dropItem(index, x, y) {

  var item = this.items[index];

  if (item) {

    this.items.splice(index, 1);
    item.x = x;
    item.y = y - item.h;
    item.vx = Math.random() * 2 - 1;
    item.vy = Math.random() * -5 - 1;

  } return item;

}

}

Inventory.prototype.collidePoint = Sprite.prototype.collidePoint;

class Animator {

constructor(frame_set, delay) {
  
  this.count = 0;
  this.delay = delay;

  this.frame_set = frame_set;// animation frames
  this.frame_index = 0;// playhead
  this.frame_value = frame_set[0];// current frame

}

animate() {

  this.count ++;

  if (this.count > this.delay) {

    this.count = 0;

    this.frame_index = (this.frame_index == this.frame_set.length - 1) ? 0 : this.frame_index + 1;
    this.frame_value = this.frame_set[this.frame_index];


  }

}

}
     
      setInterval(updateMap,50); // map animation
      setInterval(update,200); // idle animation loop
      const TILE_SIZE = 16; // size of the sprites
      var sprite_size = 16;// The actual size of sprites / tiles in the tile_sheet image
   
     
      
       //   SpriteUpRun.src ="UpRun.png";
       //   SpriteDownRun.src =  "DownRun.png";
       
      /* The player is just a simple 2d point with a moveTo function. */
      const Animation = function () {
        this.frames = 0;
      }
      const Player = function(x, y,direction) {
        this.width = width += TILE_SIZE - 4;
        this.height = width += TILE_SIZE - 4;
        this.x = x; this.y = y;
        // this.x_old = TILE_SIZE * 4 - TILE_SIZE * 0.5 + 2;
        // this.y_old = TILE_SIZE * 8;
        this.direction = direction;
        this.frames = 0;
        this.width = scaled_size
        this.velocity = 16;
        this.sprites = {
         stand:{
          idle: idle = new Image(),
          cropWidth: sprite_size,
          width: scaled_size
         },
         run:{
           right: rightrun= new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         },
         up:{
          up: uprun= new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         },
         down:{
          down: downrun= new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         },
         left:{
          left: leftrun = new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         }
        

       }
       this.currentSprite = this.sprites.stand.idle;
       this.currentCropWidth = 16;
      };
     
      function updateMap() {
        
      }
      Player.prototype = {

        moveTo:function(x, y) {

          /* Gradually moves the player closer to x, y every time moveTo is called. */
          this.x += (x - this.x - scaled_size * 0.5) * 0.5;
          this.y += (y - this.y - scaled_size * 0.5) * 0.5;

        }, 
   
        Draw:function(image){ 
          var player_sprite = 16;
          this.height = 120;
          this.width = 120;
         
          /* Draw the player. Remember to offset by the viewport position and
          center screen position. */
          context.drawImage(this.currentSprite, this.currentCropWidth * player.frames, 0, this.currentCropWidth , sprite_size, Math.round(player.x - viewport.x + width * 0.5 - viewport.w * 0.5), Math.round(player.y - viewport.y + height * 0.5 - viewport.h * 0.5), scaled_size, scaled_size);

      
        }

      };
      
      function update() {
        
           player.frames++;
          if (player.frames >= 3 || this.currentSprite === player.sprites.stand.idle || this.currentSprite === player.sprites.up.up || this.currentSprite === player.sprites.left.left) {
            player.frames = 0;
            
          } 
          
 
      }
          
         //   else if (player.frames >= 3 && this.currentSprite === player.sprites.stand.right) {
          //    player.frames = 0;
          //  }
      
   

      /* The viewport (camera) is a rectangular region that defines the visible
      area of the map to be drawn. It's x, y coordinates are relative to the map
      itself, but you can easily draw its contents in a stationary location on screen,
      thus giving the effect of scrolling. */
      const Viewport = function(x, y, w, h) {

        this.x = x; this.y = y; this.w = w; this.h = h;

      };

      Viewport.prototype = {

        scrollTo:function(x, y) {

          this.x = x - this.w * 0.5;// Rigid scrolling
          this.y = y - this.w * 0.5;

        
          //this.x += (x - this.x - this.w * 0.5) * 0.05;
          //this.y += (y - this.y - this.h * 0.5) * 0.05;

        }

      };

      var scaled_size = 65;// The size I want my sprites to be;
      var tile_set = new Image();
      var columns   = 24;// columns and rows in map below
      var rows      = 24;
      var map = [23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,1,2,2,2,2,2,2,2,2,3,23,23,23,23,23,23,23,23,23,
                 23,23,23,1,2,16,14,14,14,14,14,14,14,5,10,3,23,23,23,23,23,23,23,23,
                 23,23,23,7,4,15,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,23,23,7,8,9,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,1,2,2,11,8,9,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,1,2,2,16,14,14,14,14,15,23,23,23,
                 23,23,23,7,9,23,23,23,23,1,2,2,16,14,14,15,23,23,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,1,2,16,14,14,15,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,13,17,2,2,16,14,15,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,13,14,14,15,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23];

   var layer2 = [18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,20,18,18,18,18,18,20,20,20,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,20,20,20,20,18,18,18,18,19,19,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,20,18,18,18,18,19,19,19,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,20,19,19,19,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,20,19,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,1,2,2,2,2,2,3,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,1,11,8,8,8,8,8,9,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,8,10,2,3,0,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,8,8,8,9,6,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,4,14,14,15,12,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,9,18,18,18,18,18,18,18,21,18,18,18,18,
                 18,18,18,18,18,13,14,14,14,14,14,15,18,18,18,18,18,18,18,18,18,18,18,18, // montain end
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18];

            

      /* The drawing context of the on screen canvas */
      var context = document.querySelector("canvas").getContext("2d");
      var buffer= document.createElement("canvas").getContext("2d");
      /* The width and height of the inside of the browser window */
      var height = document.documentElement.clientHeight;
      var width  = document.documentElement.clientWidth;
      
      
    
      var player = new Player(100, 100,this.direction);
      var animation = new Animation();  

      var animations = {

       
        20: new Animator([22,23,24,25,26], 40)
                   

      }; 

      var inventory = new Inventory(120, 8, 128, 32);
      var items = [new Sprite(Math.random() * 240, 100, 96, 16, TILE_SIZE, TILE_SIZE),
                   new Sprite(Math.random() * 240, 100, 0, 32, TILE_SIZE, TILE_SIZE),
                   new Sprite(Math.random() * 240, 100, 16, 32, TILE_SIZE, TILE_SIZE),
                   new Sprite(Math.random() * 240, 100, 32, 32, TILE_SIZE, TILE_SIZE),
                   new Sprite(Math.random() * 240, 100, 48, 32, TILE_SIZE, TILE_SIZE),
                   new Sprite(Math.random() * 240, 100, 64, 32, TILE_SIZE, TILE_SIZE),
                   new Sprite(Math.random() * 240, 100, 80, 32, TILE_SIZE, TILE_SIZE),
                   new Sprite(Math.random() * 240, 100, 96, 32, TILE_SIZE, TILE_SIZE)];


      const keys = {
        right: {
          pressed: false
        },
        left: {
          pressed: false
        },
        up: {
          pressed: false
        },
        down: {
          pressed: false
        }
      }
      var viewport = new Viewport(600, 600, 800, 800);

      var pointer = { x:20, y:20,down:false };// The adjusted mouse position

      function loop() {// The game loop
        let player_index = Math.floor((player.y + scaled_size * 0.5) / scaled_size) * columns + Math.floor((player.x + scaled_size * 0.5) / scaled_size);

        window.requestAnimationFrame(loop);

          Object.values(animations).forEach(animator => {

           animator.animate();

          });
          
         
          var height = document.documentElement.clientHeight;
          var width  = document.documentElement.clientWidth;

          /* Resize canvas on every frame */
          context.canvas.height = height;
          context.canvas.width  = width;

          context.imageSmoothingEnabled = false;// prevent antialiasing of drawn image
               // Click inventory
          if (pointer.down && inventory.items.length > 0 && inventory.collidePoint(pointer)) {
          
          let index = Math.floor((pointer.x - inventory.x) / (inventory.w / inventory.columns));

          pointer.x = player.x + player.w * 0.5;

          let item = inventory.dropItem(index, player.x, player.y);

          if (item) items.unshift(item);

        }





        

          player.moveTo(pointer.x, pointer.y);
          viewport.scrollTo(player.x, player.y);

          /* Get the min and max column and row in the map to draw. For the min
          column and row (x and y) we use floor to round down and for the max we
          use ceil to round up. We want to get the rows and columns under the borders
          of the viewport rectangle. This is visualized by the white square in the example. */
          var x_min = Math.floor(viewport.x / scaled_size);
          var y_min = Math.floor(viewport.y / scaled_size);
          var x_max = Math.ceil((viewport.x + viewport.w) / scaled_size);
          var y_max = Math.ceil((viewport.y + viewport.h) / scaled_size);

          /* the min and max column and row values cannot go beyond the boundaries
          of the map. Those values are 0 and the number of columns and rows in the map. */
          if (x_min < 0) x_min = 0;
          if (y_min < 0) y_min = 0;
          if (x_max > columns) x_max = columns;
          if (y_max > rows) y_max = rows;

       

          
          /* Now we loop through the tiles in the map, but only between the min
          and max columns and rows that the viewport is over. To do this we use two
          for loops, one for the columns (x) and one for the rows (y) of the map. */
 
          for (let x = x_min; x < x_max; x ++) {

            for (let y = y_min; y < y_max; y ++) {

              let value = map[y * columns + x];// Tile value
              let layer2value = layer2[y * columns + x];// Tile value
             
         

              var tile_x = Math.floor(x * scaled_size - viewport.x + width * 0.5 - viewport.w * 0.5);// Tile x destination for drawing
              var tile_y = Math.floor(y * scaled_size - viewport.y + height * 0.5 - viewport.h * 0.5);// Tile y destination for drawing

              // Draw tile from tile_sheet
              const layermap = context.drawImage(tile_sheet, value * sprite_size, 0, sprite_size, sprite_size, tile_x, tile_y, scaled_size, scaled_size);
              
                /* Draw the buffer to the canvas. This takes care of scaling. */
              // this.context.drawImage(this.buffer.canvas, 0, 0, this.buffer.canvas.width, this.buffer.canvas.height, 0, 0, this.context.canvas.width, this.context.canvas.height);
             
              // Draw layer 2 on top of map
              let value2 = layer2[y * columns + x];// Tile value   
                if (animations[value2]) value2 = animations[value2].frame_value;
              const layermap2 = context.drawImage(layer2_sheet, value2 * sprite_size, 0, sprite_size, sprite_size, tile_x, tile_y, scaled_size, scaled_size);
               
            }
            if (keys.right.pressed && player.direction === 'right' && player.currentSprite !== player.sprites.run.right){
              player.frames = 1;
              player.currentSprite = player.sprites.run.right;
              player.currentCropWidth = player.sprites.run.cropWidth;
              player.width = player.sprites.run.width;
            }
            else if (keys.left.pressed && player.direction === 'left' && player.currentSprite !== player.sprites.left.left) {
              player.frames = 1;
              player.currentSprite = player.sprites.left.left;
              player.currentCropWidth = player.sprites.left.cropWidth;
              player.width = player.sprites.left.width;
             
            }
            else if (keys.up.pressed && player.direction === 'up' && player.currentSprite !== player.sprites.up.up) {
              player.frames = 1;
              player.currentSprite = player.sprites.up.up;
              player.currentCropWidth = player.sprites.up.cropWidth;
              player.width = player.sprites.up.width;
            }  
            else if (keys.down.pressed && player.direction === 'down' && player.currentSprite !== player.sprites.down.down) {
              player.frames = 1;
              player.currentSprite = player.sprites.down.down;
              player.currentCropWidth = player.sprites.down.cropWidth;
              player.width = player.sprites.down.width;
            }


            var front_item_index = undefined;// Index of item at very front of screen 
         /* Draw the items */
        for (let index = items.length - 1; index > -1; -- index) {

          let item = items[index];

          if (item.y + item.h >= player_index && item.collideRect(player) && pointer.down && item.collidePoint(pointer)) {
              
            front_item_index = index;// store the frontmost item index

          }

          item.updatePosition(1, 1, player_index);

          buffer.drawImage(tile_set, item.sx, item.sy, item.w, item.h, Math.round(item.x), Math.round(item.y), item.w, item.h);

        }

         // If there is an item selected, add it to the inventory
         if (front_item_index != undefined && inventory.addItem(items[front_item_index])) items.splice(front_item_index, 1); 

        /* Draw the inventory */
        buffer.fillStyle = inventory.color;
        buffer.fillRect(inventory.x, inventory.y, inventory.w, inventory.h);

        for (let index = inventory.items.length - 1; index > -1; -- index) {

        let item = inventory.items[index];
        let dest_x = inventory.x + index * TILE_SIZE * 2;
    
        buffer.drawImage(tile_set, item.sx, item.sy, item.w, item.h, dest_x, inventory.y, TILE_SIZE * 2, TILE_SIZE * 2);

        }

          /* Draw to the display context */
          context.drawImage(buffer.canvas, 0, 0, buffer.canvas.width, buffer.canvas.height, 0, 0, context.canvas.width, context.canvas.height);

        pointer.down = false;
      
     
          } // end of loop


          buffer.canvas.height = rows * TILE_SIZE;
         buffer.canvas.width  = columns * TILE_SIZE;
         buffer.imageSmoothingEnabled = false;
          

        
          
         
          
          // change the tile if player stands on it
          if (layer2[player_index] == 20 || map[player_index] == 21) layer2[player_index] = 18; 
    

    


          if (pointer.y < 0) {
            console.log('hit wall');
            pointer.y = 0;
            

          } else if (pointer.y + scaled_size > buffer.canvas.height ) {

            console.log('hit wall');
           // pointer.y = 0;
         

          }

          if (pointer.x < 0) {
            console.log('hit wall');
          pointer.x = 0;
        

          } else if (pointer.x + scaled_size > buffer.canvas.width ) {
            console.log('hit wall');
           // pointer.x = 0;
         

          }
          
        
      
       
          player.Draw(idle);

          /* Draw the viewport rectangle. */
          context.fillStyle = "#FF0000";
          context.fillRect(width * 0.5 - viewport.w * 0.5, height * 0.4 + viewport.h * 0.5, viewport.w, 10);
          context.font = "20px Arial";
          context.fillText("HP",width * 0.5 - viewport.w * 0.5, height * 0.4 + viewport.h * 0.5);
         
          context.rect(width * 0.5 - viewport.w * 0.5, height * 0.4 + viewport.h * 0.5, viewport.w, 10);
          context.stroke();
          
        
 
      }
     
      var tile_sheet = new Image();
      var player_sheet = new Image();
      var layer2_sheet = new Image();


      tile_set.addEventListener("load", (event) => { loop(); });
      tile_set.src = "weapons.png";

      tile_sheet.addEventListener("load", (event) => { loop(); });

      tile_sheet.src = "map3.png";
      layer2_sheet.src = "layer2.png";
      player_sheet.src = "player.png";
      rightrun.src = "LeftRightRun.png";
      idle.src = "idle.png";
      uprun.src = "UpRun.png";
      downrun.src = "DownRun.png";
      leftrun.src = "leftrun.png";
     
      document.addEventListener("keydown", (event) => {
     
     switch (event.key) {
    case "ArrowDown": 
    pointer.y += player.velocity; 
    
    player.direction = 'down'; 
    keys.down.pressed = true ; 
 

   
      // code for "down arrow" key press.
      break;
    case "ArrowUp": 
    pointer.y -= player.velocity;
    player.direction = 'up'; 
    keys.up.pressed = true ; 
   
      // code for "up arrow" key press.
      break;
    case "ArrowLeft":
    pointer.x -= player.velocity;  
    player.direction = 'left'; 
    keys.left.pressed = true ; 
    
   
  
    
  

      // code for "left arrow" key press.
      break;
    case "ArrowRight":   
       pointer.x += player.velocity;
       player.direction = 'right';
       keys.right.pressed = true ; 
     
      
      // code for "right arrow" key press.
      break;
    default:
   
      return; // Quit when this doesn't handle the key event.
      
  }
     

      });

      document.addEventListener("keyup", (event) => {
     
     switch (event.key) {
    case "ArrowDown": 
    keys.down.pressed = false ; 
  
    
    player.currentSprite = player.sprites.stand.idle;
              player.currentCropWidth = player.sprites.stand.cropWidth;
              player.width = player.sprites.stand.width;
     
  
 
   
      break;
    case "ArrowUp": 
    keys.up.pressed = false ; 
    player.currentSprite = player.sprites.stand.idle;
              player.currentCropWidth = player.sprites.stand.cropWidth;
              player.width = player.sprites.stand.width;
   
      break;
    case "ArrowLeft":
    keys.left.pressed = false ; 
    player.currentSprite = player.sprites.stand.idle;
              player.currentCropWidth = player.sprites.stand.cropWidth;
              player.width = player.sprites.stand.width;
      break;
    case "ArrowRight":   
    keys.right.pressed = false ; 
    
    player.currentSprite = player.sprites.stand.idle;
              player.currentCropWidth = player.sprites.stand.cropWidth;
              player.width = player.sprites.stand.width;
     
     
      break;
    default:
   
      
  }
 });
} 
    </script>

  </body>

</html>