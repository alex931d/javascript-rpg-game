<!DOCTYPE html>

<html>

  <head>

    <meta charset = "utf-8">
    <meta name = "viewport" content = "width=device-width">
   
    <title>Action-light</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./rain.css">
    <style>
      

      * { margin:0; padding:0; }

      html, body  {
         background-color:#000000d7; height:100%; position:relative; width:100%;
         /* background-image: url(grass.png);  */
        position: relative;
        display:grid;
        

        
          
        
        }

      canvas { height:100%;  width:100%;
          box-shadow: 9px 10px 5px 0px rgba(255,255,255,0.75);
-webkit-box-shadow: 9px 10px 5px 0px rgba(255,255,255,0.75);
-moz-box-shadow: 9px 10px 5px 0px rgba(255,255,255,0.75); 
align-self: center;
justify-content: center;
image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
   
      }
 


      h1{
        color: white;
        font-family: 'VT323', monospace;
        font-size: 4rem;
      }
 
     
     
    
   
      canvas img{
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
         
      }
   

    </style>

  </head>

  <body class="splat-toggle">
    <div class="rain front-row"></div>
  

  </div>

    <canvas></canvas>
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha512-aVKKRRi/Q/YV+4mjoKBsE4x3H+BkegoM/em46NNlCqNTmUYADjBbeNefNxYV7giUp0VxICtqdrbqU7iVaeZNXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="./rain.js"></script>
    <script type = "text/javascript">



     






//  var mainMusic = new Audio('./sounds/main.mp3');

// mainMusic.play();




// start game






     
 document.addEventListener('load',function() {
    
  });
   var a = 1;
  class Npc{
    constructor(x,y,sx,sy,w,h){

      this.x = x; this.y = y; this.sx = sx; this.sy = sy; this.w = w; this.h = h;

      this.vx = this.vy = 0;
    }
    
  }

  class Sprite {

constructor(x, y, sx, sy, w, h) {

  this.x = x; this.y = y; this.sx = sx; this.sy = sy; this.w = w; this.h = h;

  this.vx = this.vy = 0;

}

collidePoint(point) {

  if (point.x < this.x || point.x > this.x + this.w || point.y < this.y || point.y > this.y + this.h) return false;

  return true;

}

collideRect(sprite) {
  
  if (this.x > sprite.x + sprite.w || this.x + this.w < sprite.x || this.y > sprite.y + sprite.h || this.y + this.h < sprite.y) return false;

  return true;
      
}

updatePosition(gravity, friction, floor) {

  this.vy += gravity;

  this.x += this.vx;
  this.y += this.vy;

  this.vx *= friction;
  this.vy *= friction;

  if (this.y + this.h > floor) {

    this.y = floor - this.h;
    this.vy = 0;

  }

}

}

     
  class Inventory {

constructor(x, y, w, h) {

  this.x = x; this.y = y; this.w = w; this.h = h;
  this.color = "rgba(255, 255, 255, 0.5)";
  this.items = new Array();
  this.columns = 4;

}

addItem(sprite) {
  
  if (this.items.length == this.columns) {

    sprite.vy = -4;
    return false;

  }

  this.items.push(sprite)

  return true;
      
}

dropItem(index, x, y) {

  var item = this.items[index];

  if (item) {

    this.items.splice(index, 1);
    item.x = x;
    item.y = y - item.h;
    item.vx = Math.random() * 2 - 1;
    item.vy = Math.random() * -5 - 1;

  } return item;

}

}

Inventory.prototype.collidePoint = Sprite.prototype.collidePoint;

class Animator {

constructor(frame_set, delay) {
  
  this.count = 0;
  this.delay = delay;

  this.frame_set = frame_set;// animation frames
  this.frame_index = 0;// playhead
  this.frame_value = frame_set[0];// current frame

}

animate() {

  this.count ++;

  if (this.count > this.delay) {

    this.count = 0;

    this.frame_index = (this.frame_index == this.frame_set.length - 1) ? 0 : this.frame_index + 1;
    this.frame_value = this.frame_set[this.frame_index];


  }

}

}
     
   
  
     
      
       //   SpriteUpRun.src ="UpRun.png";
       //   SpriteDownRun.src =  "DownRun.png";
       
      /* The player is just a simple 2d point with a moveTo function. */
      const Animation = function () {
        this.frames = 0;
      }
      const Player = function(x, y,direction) {
      
        this.x = x; this.y = y;
        // this.x_old = TILE_SIZE * 4 - TILE_SIZE * 0.5 + 2;
        // this.y_old = TILE_SIZE * 8;
        this.direction = direction;
        this.frames = 0;
        this.width = scaled_size
        this.velocity = 16;
        this.sprites = {
         standLeft:{
          idle: idle_left = new Image(),
          cropWidth: sprite_size,
          width: scaled_size
         },
         standRight:{
          idle: idle_right = new Image(),
          cropWidth: sprite_size,
          width: scaled_size
         },
         run:{
           right: rightrun= new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         },
         up:{
          up: uprun= new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         },
         down:{
          down: downrun= new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         },
         left:{
          left: leftrun = new Image(),
           cropWidth: sprite_size * 1, //  multiples current sprite size with 2 when right 
           width: scaled_size * 2
         },
         attackRight:{
          attackRight: attackright = new Image(),
          cropWidth: sprite_size * 6,
          width: scaled_size * 6
         },
         attackLeft:{
          attackLeft: attackleft = new Image(),
          cropWidth: sprite_size * 6,
          width: scaled_size * 6
         }
  
        

       }
       this.currentSprite = this.sprites.standRight.idle;
       this.currentCropWidth = 16;
      };
     
      function updateMap() {
        
      }
      Player.prototype = {

        moveTo:function(x, y) {

          /* Gradually moves the player closer to x, y every time moveTo is called. */
          this.x += (x - this.x - scaled_size * 0.5) * 0.3;
          this.y += (y - this.y - scaled_size * 0.5) * 0.3;

        }, 

        Draw:function(image){ 
          var player_sprite = 16;
          this.height = 120;
         

         
          /* Draw the player. Remember to offset by the viewport position and
          center screen position. */
          context.shadowColor = "rgba(0, 0, 0, 0.30)";
          context.shadowBlur = 5;
          context.shadowOffsetX = 5;
          context.shadowOffsetY = -2;
      
          context.drawImage(this.currentSprite, this.currentCropWidth * player.frames, 0, this.currentCropWidth , 32, Math.round(player.x - viewport.x + width * 0.5 - viewport.w * 0.5), Math.round(player.y - viewport.y + height * 0.5 - viewport.h * 0.5), scaled_size * a, scaled_size * 2);

      
        }

      };
      
      function update() {
        
           player.frames++;
        
          if (player.frames >= 3 || this.currentSprite === player.sprites.standRight.idle ||
           this.currentSprite === player.sprites.up.up || this.currentSprite === player.sprites.left.left ||
            this.currentSprite === player.sprites.standLeft.idle || this.currentSprite === player.sprites.run.right ||
             this.currentSprite === player.sprites.attackLeft.attackLeft || this.currentSprite === player.sprites.attackRight.attackRight ) {
            player.frames = 0;
            
          } 
         
          
 
      } 
      function mapUpdate() {
            layer3[216] = 106;
            layer3[240] = 109;
            layer3[264] = 112;
            layer3[217] = 107;
            layer3[241] = 110;
            layer3[265] = 113;
            layer3[218] = 108;
            layer3[242] = 111;
            layer3[266] = 114;



            layer3[138] = 106;
            layer3[162] = 109;
            layer3[186] = 112;
            layer3[139] = 107;
            layer3[163] = 110;
            layer3[187] = 113;
            layer3[140] = 108;
            layer3[164] = 111;
            layer3[188] = 114;
          }
 
          
         //   else if (player.frames >= 3 && this.currentSprite === player.sprites.stand.right) {
          //    player.frames = 0;
          //  }
      
   

      /* The viewport (camera) is a rectangular region that defines the visible
      area of the map to be drawn. It's x, y coordinates are relative to the map
      itself, but you can easily draw its contents in a stationary location on screen,
      thus giving the effect of scrolling. */
      const Viewport = function(x, y, w, h) {

        this.x = x; this.y = y; this.w = w; this.h = h;

      };

      Viewport.prototype = {

        scrollTo:function(x, y) {

          this.x = x - this.w * 0.5;// Rigid scrolling
          this.y = y - this.w * 0.5;

        
          //this.x += (x - this.x - this.w * 0.5) * 0.05;
          //this.y += (y - this.y - this.h * 0.5) * 0.05;

        }

      };  
      setInterval(update,150);
      setInterval(mapUpdate,10); // player animation loop
      const TILE_SIZE = 16; // size of the sprites
      var sprite_size = 16;// The actual size of sprites / tiles in the tile_sheet image
      
      var rain = document.querySelector('.rain');
      var tile_sheet = new Image();
      var player_sheet = new Image();
      var layer2_sheet = new Image(); 
      var layer3_sheet = new Image(); 
      var tile_set = new Image();
      var scaled_size = 65;// The size I want my sprites to be;
    
      var columns   = 24;// columns and rows in map below
      var rows      = 24;
      var map = [23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,1,2,2,2,2,2,2,2,2,3,23,23,23,23,23,23,23,23,23,
                 23,23,23,1,2,16,14,14,14,14,14,14,14,5,10,3,23,23,23,23,23,23,23,23,
                 23,23,23,7,4,15,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,23,23,7,8,9,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,1,2,2,11,8,9,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,1,2,2,16,14,14,14,14,15,23,23,23,
                 23,23,23,7,9,23,23,23,23,1,2,2,16,14,14,15,23,23,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,1,2,16,14,14,15,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,13,17,2,2,16,14,15,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,13,14,14,15,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23];

   var layer2 = [18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,31,32,32,32,32,32,32,
                 18,18,18,18,18,20,18,18,18,18,18,20,20,20,18,18,18,31,32,32,32,32,32,32,
                 18,18,18,18,18,18,18,18,18,20,20,20,20,18,18,18,80,31,32,32,32,32,32,32,
                 18,18,20,19,18,18,18,18,18,18,18,20,18,18,18,18,19,31,32,32,32,32,32,32,
                 18,18,18,20,18,18,18,18,18,18,18,18,18,18,18,19,19,31,32,32,32,32,32,32,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,67,19,31,32,32,32,32,32,32, //
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,34,35,35,35,38,32,32,
                 18,18,19,18,18,18,18,69,18,20,20,18,18,18,18,18,18,18,18,18,18,31,32,32,
                 18,19,19,18,18,18,1,2,2,2,2,2,3,18,18,18,18,18,18,18,18,31,32,32,
                 18,18,18,18,18,1,11,8,8,8,8,8,9,18,18,18,18,18,18,18,18,31,32,32,
                 18,18,18,18,18,7,8,8,8,8,8,8,10,2,3,0,18,18,18,18,18,31,32,32,
                 18,18,18,18,18,7,8,8,8,8,8,8,8,8,9,6,18,18,18,18,18,31,32,32,
                 18,18,18,18,18,7,8,8,8,8,8,4,14,14,15,12,18,18,18,18,18,31,32,32,
                 18,18,18,18,18,7,8,8,8,8,8,9,18,18,18,18,18,18,18,21,18,31,32,32,
                 18,18,18,18,18,13,14,14,14,14,14,15,18,18,18,18,18,18,18,18,18,31,32,32, // montain end
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,28,29,29,29,40,32,32,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,28,29,29,40,32,32,32,32,32,32,
                 18,18,18,18,18,18,18,18,18,18,18,28,29,29,40,32,32,32,32,32,32,32,32,32,
                 18,18,18,18,18,18,18,18,18,18,18,31,32,32,32,32,32,32,32,32,32,32,32,32,
                 29,29,29,29,29,29,29,29,29,29,29,40,32,32,32,32,32,32,32,32,32,32,32,32,
                 32,32,32,32,32,32,32,32,32,32,32,32,32,37,35,35,35,35,35,35,35,35,35,38,
                 32,32,32,32,32,32,32,32,32,32,32,32,32,33,18,18,18,18,18,18,18,18,18,31,
                 32,32,32,32,32,32,32,32,32,32,32,32,32,39,29,29,29,29,29,29,29,29,29,40,
                 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32];
                 



                 var layer3 = [
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,106,107,108,18,18,18, 
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,109,110,111,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,112,113,114,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,115,116,117,18,18,18,
                 106,107,108,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 109,110,111,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 112,113,114,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 115,116,117,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18, 
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,38,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18];


            

      /* The drawing context of the on screen canvas */
      
      var context = document.querySelector("canvas").getContext("2d");
     
      
      var buffer= document.createElement("canvas").getContext("2d");
      /* The width and height of the inside of the browser window */
      var height = document.documentElement.clientHeight;
      var width  = document.documentElement.clientWidth;
      
      
    
      var player = new Player(100, 100,this.direction);
      var animation = new Animation();  

      var animations = {

       
        20: new Animator([22,23,24,25,26], 30),
        67: new Animator([67,68], 30),
        // ocean animation.
        31: new Animator([31,44,57], 10),
        35: new Animator([35,48,61], 10),
        30: new Animator([30,42,55], 10),
        38: new Animator([38,51,64], 10),
        40: new Animator([40,53,66], 10),
        29: new Animator([29,42,55], 10),     

      }; 

     


      const keys = {
        right: {
          pressed: false
        },
        left: {
          pressed: false
        },
        up: {
          pressed: false
        },
        down: {
          pressed: false
        }
      }
      var viewport = new Viewport(600, 600, 800, 800);

      var pointer = { x:0, y:0,down:false };// The adjusted mouse position

      function loop() {// The game loop
        let player_index = Math.floor((player.y + scaled_size * 0.5) / scaled_size) * columns + Math.floor((player.x + scaled_size * 0.5) / scaled_size);

        window.requestAnimationFrame(loop);

          Object.values(animations).forEach(animator => {

           animator.animate();

          });
          
         
          var height = document.documentElement.clientHeight;
          var width  = document.documentElement.clientWidth;

          /* Resize canvas on every frame */
          context.canvas.height = height;
          context.canvas.width  = width;

          context.imageSmoothingEnabled = false;// prevent antialiasing of drawn image






        

          player.moveTo(pointer.x, pointer.y);
          viewport.scrollTo(player.x, player.y);

          /* Get the min and max column and row in the map to draw. For the min
          column and row (x and y) we use floor to round down and for the max we
          use ceil to round up. We want to get the rows and columns under the borders
          of the viewport rectangle. This is visualized by the white square in the example. */
          var x_min = Math.floor(viewport.x / scaled_size);
          var y_min = Math.floor(viewport.y / scaled_size);
          var x_max = Math.ceil((viewport.x + viewport.w) / scaled_size);
          var y_max = Math.ceil((viewport.y + viewport.h) / scaled_size);

          /* the min and max column and row values cannot go beyond the boundaries
          of the map. Those values are 0 and the number of columns and rows in the map. */
          if (x_min < 0) x_min = 0;
          if (y_min < 0) y_min = 0;
          if (x_max > columns) x_max = columns;
          if (y_max > rows) y_max = rows;

       

          
          /* Now we loop through the tiles in the map, but only between the min
          and max columns and rows that the viewport is over. To do this we use two
          for loops, one for the columns (x) and one for the rows (y) of the map. */
 
          for (let x = x_min; x < x_max; x ++) {

            for (let y = y_min; y < y_max; y ++) {

              let value = map[y * columns + x];// Tile value
           
             
         

              var tile_x = Math.floor(x * scaled_size - viewport.x + width * 0.5 - viewport.w * 0.5);// Tile x destination for drawing
              var tile_y = Math.floor(y * scaled_size - viewport.y + height * 0.5 - viewport.h * 0.5);// Tile y destination for drawing

              // Draw tile from tile_sheet
          
              const layermap = context.drawImage(tile_sheet, value * sprite_size, 0, sprite_size, sprite_size, tile_x, tile_y, scaled_size, scaled_size);
           if (layer3[player_index] == 114 ||
                layer3[player_index] == 113 ||
                 layer3[player_index] == 112 ||
                  layer3[player_index] == 111 ||
                   layer3[player_index] == 110 ||
                    layer3[player_index] == 109 ||
                     layer3[player_index] == 108 ||
                      layer3[player_index] == 107 ||
                       layer3[player_index] == 106) layer3[player_index] = 18;
                       
                       
                   
                /* Draw the buffer to the canvas. This takes care of scaling. */
              // this.context.drawImage(this.buffer.canvas, 0, 0, this.buffer.canvas.width, this.buffer.canvas.height, 0, 0, this.context.canvas.width, this.context.canvas.height);
             
              // Draw layer 2 on top of map
              let value2 = layer2[y * columns + x];// Tile value   
              let value3 = layer3[y * columns + x];
               if (animations[value2]) value2 = animations[value2].frame_value;
              const layermap2 = context.drawImage(layer2_sheet, value2 * sprite_size, 0, sprite_size, sprite_size, tile_x, tile_y, scaled_size, scaled_size);
              const layermap3 = context.drawImage(layer3_sheet, value3 * sprite_size, 0, sprite_size, sprite_size, tile_x, tile_y, scaled_size, scaled_size);
            
            }     
            if (player.direction == 'right' && player.direction === 'right' && player.currentSprite !== player.sprites.run.right && player.currentSprite !== player.sprites.attackRight.attackRight){
              player.frames = 1;
              a = 1;
              player.currentSprite = player.sprites.run.right;
              player.currentCropWidth = player.sprites.run.cropWidth;
              player.width = player.sprites.run.width;
            }
            else if (player.direction == 'left' && player.direction === 'left' && player.currentSprite !== player.sprites.left.left && player.currentSprite !== player.sprites.attackLeft.attackLeft) {
              player.frames = 1;
              a = 1;
              player.currentSprite = player.sprites.left.left;
              player.currentCropWidth = player.sprites.left.cropWidth;
              player.width = player.sprites.left.width;
             
            }
            else if (player.direction == 'up' && player.direction === 'up' && player.currentSprite !== player.sprites.up.up ) {
              player.frames = 1;
              a = 1;
              player.currentSprite = player.sprites.up.up;
              player.currentCropWidth = player.sprites.up.cropWidth;
              player.width = player.sprites.up.width;
            }  
            else if (player.direction == 'down' && player.direction === 'down' && player.currentSprite !== player.sprites.down.down) {
              player.frames = 1;
              a = 1;
              player.currentSprite = player.sprites.down.down;
              player.currentCropWidth = player.sprites.down.cropWidth;
              player.width = player.sprites.down.width;
            }

            // else if (!player.direction == 'idle' && player.direction === 'down' && player.currentSprite !== player.sprites.down.down) {
            //   player.frames = 1;
            //   player.currentSprite = player.sprites.stand.idle;
            //   player.currentCropWidth = player.sprites.stand.cropWidth;
            //   player.width = player.sprites.stand.width;
            // }

            // else if (!player.direction == 'idle' && player.direction === 'up' && player.currentSprite !== player.sprites.up.up) {
            //   player.frames = 1;
            //   player.currentSprite = player.sprites.stand.idle;
            //   player.currentCropWidth = player.sprites.stand.cropWidth;
            //   player.width = player.sprites.stand.width;
            // }
            // else if (!player.direction == 'idle' && player.direction === 'left' && player.currentSprite !== player.sprites.left.left) {
            //   player.frames = 1;
            //   player.currentSprite = player.sprites.stand.idle;
            //   player.currentCropWidth = player.sprites.stand.cropWidth;
            //   player.width = player.sprites.stand.width;
            // }
            // else if (!player.direction == 'idle' && player.direction === 'right' && player.currentSprite !== player.sprites.right.right) {
            //   player.frames = 1;
            //   player.currentSprite = player.sprites.stand.idle;
            //   player.currentCropWidth = player.sprites.stand.cropWidth;
            //   player.width = player.sprites.stand.width;
            // }
         


   

          /* Draw to the display context */
          
            context.drawImage(buffer.canvas, 0, 0, buffer.canvas.width, buffer.canvas.height, 0, 0, context.canvas.width, context.canvas.height);

       
           console.log(player_index);
           ;
           if (player.direction == "left") {
            rain.style.transform = "rotate(-20deg)";
           }
          else if(player.direction == "right"){
            rain.style.transform = "rotate(20deg)";
          }  
          else if(player.direction == "left-up" || player.direction == "right-up"){
            rain.style.transform = "rotate(0deg)";
          }
          
          } // end of loop
          

          buffer.canvas.height = rows * TILE_SIZE;
         buffer.canvas.width  = columns * TILE_SIZE;
         buffer.imageSmoothingEnabled = false;
          

        
          
         
          
          // change the tile if player stands on it
          if (layer2[player_index] == 20 || map[player_index] == 21) layer2[player_index] = 18; 
    
        
         
        
          
          
       

          if (pointer.y < 0) {
            console.log('hit wall');
            pointer.y = 0;
            

          } else if (pointer.y + scaled_size> buffer.canvas.height ) {

            console.log('hit wall');
           // pointer.y = 0;
         

          }

          if (pointer.x < 0) {
            console.log('hit wall');
          pointer.x = 0;
        

          } else if (pointer.x + scaled_size > buffer.canvas.width ) {
            console.log('hit wall');
           // pointer.x = 0;
 

          }
          
        
      
       
          player.Draw(idle_right);

          /* Draw the viewport rectangle. */
          /* context.fillStyle = "#000000";
          context.shadowColor = "black";
          context.shadowBlur = 6;
          context.shadowOffsetX = 6;
          context.shadowOffsetY = 6;
          context.globalAlpha = 1;
          context.fillRect(width * 0.5 - viewport.w * 0.5, height * 0.5 + viewport.h * 0.5, viewport.w, 600);
       
        
          . */
         
      
          context.stroke();
          
        
 
      }
     
     


    

      tile_sheet.addEventListener("load", (event) => { loop(); });

      tile_sheet.src = "map3_sep.png";
      layer2_sheet.src = "layer2_sep.png";
      layer3_sheet.src = "layer2_sep.png";
      player_sheet.src = "player.png";
      rightrun.src = "player_run_right_animation.png";
      idle_right.src = "player_idle_right_animation.png";
      idle_left.src = "player_idle_left_animation.png";
      attackright.src = "player_attack_right_animation.png";
      attackleft.src = "player_attack_left_animation.png";
     
      leftrun.src = "player_run_left_animation.png";
   
      document.addEventListener('click',function (event) {
        player.currentCropWidth = 16 * 3;
       
        a = 3;
        
          if (player.direction === "right-up" || player.direction === "right" || player.direction == null || player.direction == "attack") {
          
                player.currentSprite = player.sprites.attackRight.attackRight;
                player.direction = 'attack'; 
        
        
                return;
            
          }
          if (player.direction === "left-up"|| player.direction === "left" || player.direction == null || player.direction == "attack") {
             
               player.currentSprite = player.sprites.attackLeft.attackLeft; 
               player.direction = 'attack'; 
            
       
               return;
           
            
          }
          player.currentSprite = player.sprites.standRight.idle;
          
    
      });
     
      document.addEventListener("keydown", (event) => {
     
     switch (event.key) {
    case "ArrowDown": 
    pointer.y += player.velocity; 
   
    player.direction == 'down';
  
    keys.down.pressed = true ; 
 

   
      // code for "down arrow" key press.
      break;
    case "ArrowUp": 
    pointer.y -= player.velocity;
    player.direction == 'up'
    keys.up.pressed = true ; 
   
      // code for "up arrow" key press.
      break;
    case "ArrowLeft":
    pointer.x -= player.velocity;  
    player.direction = 'left'; 
 
    keys.left.pressed = true ; 
    
   
  
    
  

      // code for "left arrow" key press.
      break;
    case "ArrowRight":   
       pointer.x += player.velocity;
       player.direction = 'right';
       
       keys.right.pressed = true ; 
     
      
      // code for "right arrow" key press.
      break;
    default:
   
      return; // Quit when this doesn't handle the key event.
      
  }
     

      });

      document.addEventListener("keyup", (event) => {
     
     switch (event.key) {
    case "ArrowDown": 
    keys.down.pressed = false ; 
    a = 1;
  
    
    player.currentSprite = player.sprites.standLeft.idle;
    player.currentCropWidth = player.sprites.standLeft.cropWidth;
    player.width = player.sprites.standLeft.width;
     
  
 
   
      break;
    case "ArrowUp": 
    keys.up.pressed = false ; 
    a = 1;
    player.currentSprite = player.sprites.standRight.idle;
    player.currentCropWidth = player.sprites.standRight.cropWidth;
    player.width = player.sprites.standRight.width;
   
      break;
    case "ArrowLeft":
    player.direction = 'left-up';
    keys.left.pressed = false ; 
    a = 1;
    player.currentSprite = player.sprites.standLeft.idle;
    player.currentCropWidth = player.sprites.standLeft.cropWidth;
    player.width = player.sprites.standLeft.width;
      break;
    case "ArrowRight":   
    player.direction = 'right-up';
    keys.right.pressed = false ;
    a = 1;
  
    player.currentSprite = player.sprites.standRight.idle;
    player.currentCropWidth = player.sprites.standRight.cropWidth;
    player.width = player.sprites.standRight.width;
     
     
      break;
    default:
   
      
  }
 });

    </script>

  </body>

</html>