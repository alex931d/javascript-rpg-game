<!DOCTYPE html>

<html>

  <head>

    <meta charset = "utf-8">
    <meta name = "viewport" content = "width=device-width">

    <title>Tile Scroll</title>

    <style>

      * { margin:0; padding:0; }

      html, body {
         background-color:black; height:100%; position:relative; width:100%;
        background-image: url(grass.png);
        position: relative;
        
        }

      canvas { height:100%; position:fixed; width:100%; }
      div{
        display: flex;
        justify-content: center;
        align-items: center;
        position: absolute;
        top: 50%;
        left: 50%;
        height: 100px;
        width: 100px;
        background-color: violet;
      }

    </style>

  </head>

  <body>

    <canvas></canvas>
    

    <script type = "text/javascript">
     
 function menu() {
  const ui = document.createElement('div');
  ui.appendChild(body);
  
  
  
  
 }
      const TILE_SIZE = 16;
      /* The player is just a simple 2d point with a moveTo function. */
      const Player = function(x, y, x_old, y_old,height,width,TILE_SIZE) {
        this.width = width += TILE_SIZE - 4;
        this.height = width += TILE_SIZE - 4;
        this.x = x; this.y = y;
        this.x_old = TILE_SIZE * 4 - TILE_SIZE * 0.5 + 2;
        this.y_old = TILE_SIZE * 8;

      };

      Player.prototype = {

        moveTo:function(x, y) {

          /* Gradually moves the player closer to x, y every time moveTo is called. */
          this.x += (x - this.x - scaled_size * 0.5) * 0.1;
          this.y += (y - this.y - scaled_size * 0.5) * 0.1;

        }

      };

      /* The viewport (camera) is a rectangular region that defines the visible
      area of the map to be drawn. It's x, y coordinates are relative to the map
      itself, but you can easily draw its contents in a stationary location on screen,
      thus giving the effect of scrolling. */
      const Viewport = function(x, y, w, h) {

        this.x = x; this.y = y; this.w = w; this.h = h;

      };

      Viewport.prototype = {

        scrollTo:function(x, y) {

          this.x = x - this.w * 0.5;// Rigid scrolling
          this.y = y - this.w * 0.5;

          // Smooth scrolling (forgot to put this in the video)
          //this.x += (x - this.x - this.w * 0.5) * 0.05;
          //this.y += (y - this.y - this.h * 0.5) * 0.05;

        }

      };

      var scaled_size = 80;// The size I want my sprites to be;
      var sprite_size = 16;// The actual size of sprites / tiles in the tile_sheet image
      var columns   = 24;// columns and rows in map below
      var rows      = 24;
      var map = [23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,1,2,2,2,2,2,2,2,2,3,23,23,23,23,23,23,23,23,23,
                 23,23,23,1,2,16,14,14,14,14,14,14,14,5,10,3,23,23,23,23,23,23,23,23,
                 23,23,23,7,4,15,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,23,13,5,10,3,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,23,23,23,7,8,9,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,23,23,23,1,2,2,11,8,9,23,23,23,
                 23,23,23,7,9,23,23,23,23,23,23,23,1,2,2,16,14,14,14,14,15,23,23,23,
                 23,23,23,7,9,23,23,23,23,1,2,2,16,14,14,15,23,23,23,23,23,23,23,23,
                 23,23,23,7,9,23,23,1,2,16,14,14,15,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,13,17,2,2,16,14,15,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,13,14,14,15,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
                 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23];

   var layer2 = [18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,20,18,18,18,18,18,20,20,20,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,20,20,20,20,18,18,18,18,19,19,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,20,18,18,18,18,19,19,19,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,20,19,19,19,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,20,19,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,1,2,2,2,2,2,3,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,1,11,8,8,8,8,8,9,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,8,10,2,3,0,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,8,8,8,9,6,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,4,14,14,15,12,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,7,8,8,8,8,8,9,18,18,18,18,18,18,18,21,18,18,18,18,
                 18,18,18,18,18,13,14,14,14,14,14,15,18,18,18,18,18,18,18,18,18,18,18,18, // montain end
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
                 18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18];

      /* The drawing context of the on screen canvas */
      var context = document.querySelector("canvas").getContext("2d");
      var buffer= document.createElement("canvas").getContext("2d");
      /* The width and height of the inside of the browser window */
      var height = document.documentElement.clientHeight;
      var width  = document.documentElement.clientWidth;
      var player_sprite = 64;
      var player = new Player(100, 100);
      var viewport = new Viewport(600, 600, 800, 800);

      var pointer = { x:0, y:0 };// The adjusted mouse position

      function loop() {// The game loop

        window.requestAnimationFrame(loop);

          var height = document.documentElement.clientHeight;
          var width  = document.documentElement.clientWidth;

          /* Resize canvas on every frame */
          context.canvas.height = height;
          context.canvas.width  = width;

          context.imageSmoothingEnabled = false;// prevent antialiasing of drawn image

          player.moveTo(pointer.x, pointer.y);
          viewport.scrollTo(player.x, player.y);

          /* Get the min and max column and row in the map to draw. For the min
          column and row (x and y) we use floor to round down and for the max we
          use ceil to round up. We want to get the rows and columns under the borders
          of the viewport rectangle. This is visualized by the white square in the example. */
          var x_min = Math.floor(viewport.x / scaled_size);
          var y_min = Math.floor(viewport.y / scaled_size);
          var x_max = Math.ceil((viewport.x + viewport.w) / scaled_size);
          var y_max = Math.ceil((viewport.y + viewport.h) / scaled_size);

          /* the min and max column and row values cannot go beyond the boundaries
          of the map. Those values are 0 and the number of columns and rows in the map. */
          if (x_min < 0) x_min = 0;
          if (y_min < 0) y_min = 0;
          if (x_max > columns) x_max = columns;
          if (y_max > rows) y_max = rows;

          /* Now we loop through the tiles in the map, but only between the min
          and max columns and rows that the viewport is over. To do this we use two
          for loops, one for the columns (x) and one for the rows (y) of the map. */
          for (let x = x_min; x < x_max; x ++) {

            for (let y = y_min; y < y_max; y ++) {

              let value = map[y * columns + x];// Tile value
              var tile_x = Math.floor(x * scaled_size - viewport.x + width * 0.5 - viewport.w * 0.5);// Tile x destination for drawing
              var tile_y = Math.floor(y * scaled_size - viewport.y + height * 0.5 - viewport.h * 0.5);// Tile y destination for drawing

              // Draw tile from tile_sheet
              context.drawImage(tile_sheet, value * sprite_size, 0, sprite_size, sprite_size, tile_x, tile_y, scaled_size, scaled_size);

                /* Draw the buffer to the canvas. This takes care of scaling. */
              // this.context.drawImage(this.buffer.canvas, 0, 0, this.buffer.canvas.width, this.buffer.canvas.height, 0, 0, this.context.canvas.width, this.context.canvas.height);
              // buffer.canvas.height = rows * columns; // = 576
              // buffer.canvas.width = rows * columns;  // = 576
              // Draw layer 2 on top of map
              let value2 = layer2[y * columns + x];// Tile value
               context.drawImage(layer2_sheet, value2 * sprite_size, 0, sprite_size, sprite_size, tile_x, tile_y, scaled_size, scaled_size);
            }

          }
      
        // gets player position
          let player_index = Math.floor((player.y + scaled_size * 0.5) / scaled_size) * columns + Math.floor((player.x + scaled_size * 0.5) / scaled_size);
          console.log(player_index);
          // change the tile if player stands on it
          if (map[player_index] == 23) map[player_index] = 22; 


          if (pointer.y < 0) {
            console.log('hit wall');
            pointer.y = 0;
         

          } else if (pointer.y + scaled_size > context.canvas.height) {

            console.log('hit wall');
            pointer.y = 0;
           

          }

          if (pointer.x < 0) {
            console.log('hit wall');
          pointer.x = 0;
         

          } else if (pointer.x + scaled_size > context.canvas.width) {
            console.log('hit wall');

          pointer.x = 0;
        

          }
          
        
      

          /* Draw the player. Remember to offset by the viewport position and
          center screen position. */
          context.drawImage(player_sheet, player_sprite, 0, sprite_size, sprite_size, Math.round(player.x - viewport.x + width * 0.5 - viewport.w * 0.5), Math.round(player.y - viewport.y + height * 0.5 - viewport.h * 0.5), scaled_size, scaled_size);

          /* Draw the viewport rectangle. */
          context.fillStyle = "#FF0000";
          context.fillRect(width * 0.5 - viewport.w * 0.5, height * 0.4 + viewport.h * 0.5, viewport.w, 10);
          context.font = "20px Arial";
          context.fillText("HP",width * 0.5 - viewport.w * 0.5, height * 0.4 + viewport.h * 0.5);
         
          context.rect(width * 0.5 - viewport.w * 0.5, height * 0.4 + viewport.h * 0.5, viewport.w, 10);
          context.stroke();
          
        
 
      }

      var tile_sheet = new Image();
      var player_sheet = new Image();
      var layer2_sheet = new Image();

      tile_sheet.addEventListener("load", (event) => { loop(); });

      tile_sheet.src = "map3.png";
      layer2_sheet.src = "layer2.png";
      player_sheet.src = "player.png";

      document.addEventListener("keydown", (event) => {
     
     switch (event.key) {
    case "ArrowDown": 
    pointer.y += 10;
    player_sheet.style.transform = "rotate(180deg)";
  
    player_sprite = 87;
      // code for "down arrow" key press.
      break;
    case "ArrowUp": 
    pointer.y -= 10;
    player_sprite = 87;
      // code for "up arrow" key press.
      break;
    case "ArrowLeft":
    pointer.x -= 10; 
    player_sheet.style.transform = "rotate(90deg)";
    
    player_sprite = 60;
  

      // code for "left arrow" key press.
      break;
    case "ArrowRight":   
       pointer.x += 10;
       player_sprite = 60;
      // code for "right arrow" key press.
      break;
    default:
      return; // Quit when this doesn't handle the key event.
      
  }
     

      });

    </script>

  </body>

</html>